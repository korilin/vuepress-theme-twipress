(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{398:function(t,n,e){"use strict";e.r(n);var r=e(2),a=Object(r.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"关系模型中的概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关系模型中的概念"}},[t._v("#")]),t._v(" 关系模型中的概念")]),t._v(" "),e("p",[t._v('1、关系 (Relation) 与关系实例：一个关系实例对应一张表，关系实例的名称，称为关系名，通常仅用关系来代表关系实例。\n2、元组 (Tuple): 二维表中的一行，代表一条记录。\n3、属性 (Attribute): 二维表的一列，代表一个属性，属性的名称即属性名。\n4、域 (Domain): 属性的取值范围。\n5、分量：元组对应列的属性值。\n6、候选码：可唯一标识一个关系中每行元组的属性或不包含多余属性的属性组合。\n7、主码：在多个候选码中挑选的唯一标识。\n8、关系模式：对关系的描述，是关系模型中的"型"。\n9: 关系实例：关系模式的值，是关系的数据。')]),t._v(" "),e("h3",{attrs:{id:"关系的性质"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关系的性质"}},[t._v("#")]),t._v(" 关系的性质")]),t._v(" "),e("ol",[e("li",[t._v("列是同质的，每一列中的分量必须来自同一个域，必须是同一类型的数据")]),t._v(" "),e("li",[t._v("不同的属性课来自同一个域，但必须有不同名字")]),t._v(" "),e("li",[t._v("列的顺序可以任意交换")]),t._v(" "),e("li",[t._v("关系中元组的顺序（行序）可以任意，在一个关系中可以任意交换两行的次序")]),t._v(" "),e("li",[t._v("关系中不允许出现相同的元组")]),t._v(" "),e("li",[t._v("关系中每一分量必须是不可分的数据项 "),e("strong",[t._v("（满足此条件的关系称为规范化关系，否则称为非规范化关系）")])])]),t._v(" "),e("h3",{attrs:{id:"关系模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关系模型"}},[t._v("#")]),t._v(" 关系模型")]),t._v(" "),e("p",[t._v("数据库中要区分型和值。关系数据库中，关系模式是型，关系是值。")]),t._v(" "),e("p",[e("strong",[t._v("关系的描述称为关系模式（Relation Schema）")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("形式化表示为：\nR（U，D，DOM，F）\nR   为关系名\nU   为组成关系的属性名集合\nD   为属性组U中属性所来自的域\nDOM 为属性向域的映射集合\nF   为属性间数据的依赖关系集合\n\n简记：\nR（U）或R（A1，A2，···，An）\n")])])]),e("p",[e("strong",[t._v("关系模式由关系数据结构、关系操作和关系完整性约束三部分组成")])]),t._v(" "),e("h3",{attrs:{id:"关系的码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关系的码"}},[t._v("#")]),t._v(" 关系的码")]),t._v(" "),e("p",[e("strong",[t._v("候选码（Candidate Key）")])]),t._v(" "),e("p",[t._v("能唯一识别关系中元组的一个属性或属性集，拥有唯一性（Uniqueness）和最小性（Minimum）")]),t._v(" "),e("p",[e("strong",[t._v("主码（Primary Key)")])]),t._v(" "),e("p",[t._v("在关系的多个候选码中，从中选择一个作为查询、插入和删除元组的操作变量，被选择的候选码称为主码")]),t._v(" "),e("p",[e("strong",[t._v("外码（Foreign Key）")])]),t._v(" "),e("p",[t._v("关系 R2 的一个或一组属性 X 不是 R2 的主码，而是另一个关系 R1 的主码，则该属性或属性组 X 称为 R2 的外码或外部关系键\n"),e("strong",[t._v("称关系 R2 为参照关系（Referencing Relation），关系 R1 为被参照关系（Referenced Relation）")])]),t._v(" "),e("p",[e("strong",[t._v("主属性（Prime Attribute）：")]),t._v(" 包含在主码中的各个属性称为主属性\n"),e("strong",[t._v("非主属性（Non-Prime Attribute）：")]),t._v(" 不包含在任何候选码中的属性称为非主属性（非码属性）\n所有属性的组合是关系的候选码，称为全码（All-key）")]),t._v(" "),e("h3",{attrs:{id:"关系完整性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关系完整性"}},[t._v("#")]),t._v(" 关系完整性")]),t._v(" "),e("p",[e("strong",[t._v("实体完整性（Entity Integrity）：")]),t._v(" 主码的值不能为空或部分为空\n"),e("strong",[t._v("参照完整性（Referential Integrity）：")]),t._v(" 关系 R2 的外码 X 与关系 R1 的主码相符，则 X 的每个值必须等于 R1 中的主码的某个值或者取空值\n"),e("strong",[t._v("用户自定义完整性（User-defined Integrity）：")]),t._v(" 用户针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求")]),t._v(" "),e("h3",{attrs:{id:"参考自"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考自"}},[t._v("#")]),t._v(" 参考自")]),t._v(" "),e("blockquote",[e("p",[t._v("《数据库原理及应用 第四版|微课版》 人民邮电出版社")])])])}),[],!1,null,null,null);n.default=a.exports}}]);